# 第10次作业解答

## Question

+ Exercises 1 and 5 (page 204, Advanced R)
+ Excecises 1 and 7 (page 214, Advanced R)


## Answer

### P204-1

Why are the following two invocations of `lapply()` equivalent?

```{r results='hide'}
trims <- c(0, 0.1, 0.2, 0.5)
x <- rcauchy(100)
lapply(trims, function(trim) mean(x, trim = trim))
lapply(trims, mean, x = x)
```
答:
mean(x,trim)实际上有两个参数x和trim

+ 第一种表达是构造了新的function,给定了x的值，只剩下一个参数trim, lapply可以直接对trim的每个取值调用新的函数求mean
+ 第二种表达实际上把mean的参数x直接传到lapply里了, 也是对trim每个取值求mean


### P204-5

For each model in the previous two exercises, extract R2 using
the function below.

#### Ex1
```{r}
formulas <- list(
mpg ~ disp,
mpg ~ I(1 / disp),
mpg ~ disp + wt,
mpg ~ I(1 / disp) + wt
)
lapply(formulas,lm,data=mtcars)
```



#### Ex2
```{r}
bootstraps <- lapply(1:10, function(i) {
  rows <- sample(1:nrow(mtcars), rep = TRUE)
  mtcars[rows, ]
})

lapply(bootstraps,function(t) lm(mpg~disp,data=t))
```


```{r}
rsq <- function(mod) summary(mod)$r.squared

## Ex1
cat("这是Ex1 4个模型的R-square\n")
lapply(lapply(formulas,lm,data=mtcars), rsq)

## Ex2
cat("这是Ex2 10个模型的R-square\n")
lapply(lapply(bootstraps,function(t) lm(mpg~disp,data=t)), rsq)
```


### P214-1

Use `vapply()` to:

  + a) Compute the standard deviation of every column in a numeric data frame.
  + b) Compute the standard deviation of every numeric column in a mixed data frame. 
  (Hint: you’ll need to use `vapply()` twice.)


#### (a)
```{r}
df= data.frame(a = 1:4, b= 5:8, c =9:12)

## 每一列取标准差
vapply(as.list(df),sd,numeric(1))
```
#### (b)
```{r}
df2=data.frame(a = 1:4, b=c("x","y","z","s"), c =9:12)
vapply(df2[vapply(df2, is.numeric, logical(1))], sd, numeric(1))
```


### P214-7

Implement `mcsapply()`, a multicore version of `sapply()`. Can
you implement mcvapply(), a parallel version of `vapply()`?
Why or why not?

#### mcsaplly()

下面分配四个核来构造mcsapply函数

```{r}
library(parallel)
mcsapply <- function(n, func){
  core <- makeCluster(4)    # 使用4个核
  res <- parSapply(core, n, func)   # 并行计算，n为次数，func为函数
  stopCluster(core)         # 关闭核
}
```

然后不妨尝试还是考虑前面习题中提及的计算置换数据的$R^2$

```{r}
R2 <- function(i){
  index <- sample(1:nrow(mtcars), rep = TRUE)
  m <- lm(mpg ~ disp, data = mtcars[index,])
  return(summary(m)$r.squared)
}

# 使用sapply函数进行10次
system.time(sapply(1:10, R2))
# 使用mcsapply函数进行10次
system.time(mcsapply(1:10, R2))


# 使用sapply函数进行10000次
system.time(sapply(1:10000, R2))
# 使用mcsapply函数进行10000次
system.time(mcsapply(1:10000, R2))
```


实际上，发现当样本量比较小的时候，并行计算反而比不并行所需要的时间更久，因为涉及到分配等额外消耗。当样本量比较大的时候并行计算会快很多。


#### mcvapply()

由于R中并没有现成的parVapply函数，所以并行这一步的处理无法进行