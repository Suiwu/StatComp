---
title: "Introduction to StatComp21055"
author: "兰敬国 SA21229031"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to StatComp21055}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Overview

__StatComp21055__ 是统计计算课程的期末`R`包。 它主要包括包括三个部分:

+ 首先是关于shapes data 的一些统计量的计算，包括均值计算、回归估计和模型选择(决定系数$R^2$)。

+ 第二是几个有关变量选择的一些批量化处理函数，方便平时跑模拟。大致分为3个部分: 数据生成，指标计算和画图输出。

+ 第三是平时作业汇总(见`homework.html`)


## shapes data

shapes data就是形状数据。我们想做的事情是, 比如大脑某些结构的形状, 比较常用的表示方式是坐标法, 在轮廓边缘取一些点来刻画形状(landmark法)。

我们想研究的是响应变量是shape data的情景下, 把欧氏空间的一些方法推广过来。
比如对一组大脑患有疾病的患者,我们想研究大脑某个部位的形状与患者的性别、年龄、病情是否有关，以此确定该疾病是否会影响大脑的某个部位，进而制定相应策略医治。

我们通过两张图来加深了解:

<center class="half">
    <img src=./brain.png width=30% /> 
    <img src=./mice.png width=32% />
</center>



brains 数据集  

+ 形状数据: brains$x      24\*3\*58
+ 年龄:   brains$age
+ 性别:   brains$sex   (1 for male /  2 for female)
+ 组别:   brains$grp

```{r}
library(StatComp21055)
library(BB)
library(shapes)
library(frechet)
data("brains")
## 以年龄、性别和组别作为预测变量
X=cbind(brains$age,brains$grp,brains$sex)[1:10,]
Y=brains$x[,,1:10]
## 预览一下shapes data 的样子
print(Y[,,1])
```

### 计算一下均值
```{r}
Fm=Fmean(Y)
Fm
```

### 回归估计
```{r}
## 预测一下自变量是X[1,]处的Y值
yhat=FREShape(Y,X,X[1,])

cbind(Y[,,1],yhat)

```

### 模型估计

针对不同的预测变量我们可以建立不同的模型，所以需要有个指标衡量哪个模型更好。能从欧氏空间借鉴的是决定系数($R^2$)或者调整后的决定系数($adj-R^2$)。决定系数越大说明模型拟合效果越好。

```{r}
r2=R2(Y,X)
r2
```


## 变量选择

这部分主要是




## Benchmarking _vaccR_ and _vaccC_

The source R code for _vaccR_ is as follows:
```{r,eval=FALSE}
function (age, female, ily) 
{
    p <- 0.25 + 0.3 * 1/(1 - exp(0.04 * age)) + 0.1 * ily
    p <- p * ifelse(female, 1.25, 0.75)
    p <- pmax(0, p)
    p <- pmin(1, p)
    p
}
```

The above code involves 'ifelse', 'pmax', and 'pmin', which are known to be slow. On the other hand, the following _Rcpp_ code is much faster.

```{r,eval=FALSE}
double vacc3a(double age, bool female, bool ily){
  double p = 0.25 + 0.3 * 1 / (1 - exp(0.04 * age)) + 0.1 * ily;
  p = p * (female ? 1.25 : 0.75);
  p = std::max(p, 0.0);
  p = std::min(p, 1.0);
  return p;
}
NumericVector vaccC(NumericVector age, LogicalVector female,
                    LogicalVector ily) {
  int n = age.size();
  NumericVector out(n);
  for(int i = 0; i < n; ++i) {
    out[i] = vacc3a(age[i], female[i], ily[i]);
  }
  return out;
}
```

In order to empirically benchmark _vaccR_ and _vaccC_, one generates 1,000 repicates of (age, female, ily), and save it in data{StatComp}. To load the file, one simply calls _data(data)_. The R code for benchmark _vaccR_ and _vaccC_ is as follows.

```{r,eval=TRUE}
library(StatComp21055)
library(microbenchmark)
data(data)
attach(data)
tm2 <- microbenchmark(
  vR = vaccR(age,female,ily),
  vC = vaccC(age,female,ily)
)
knitr::kable(summary(tm2)[,c(1,3,5,6)])
```

The above results show an evident computational speed gain of C++ against R.


## Benchmarking _gibbsR_ and _gibbsC_

The source R code for _vaccR_ is as follows:
```{r,eval=FALSE}
gibbsR <- function(N, thin) {
  mat <- matrix(nrow = N, ncol = 2)
  x <- y <- 0
  for (i in 1:N) {
    for (j in 1:thin) {
      x <- rgamma(1, 3, y * y + 4)
      y <- rnorm(1, 1 / (x + 1), 1 / sqrt(2 * (x + 1)))
    }
    mat[i, ] <- c(x, y)
  }
  mat
}
```

The above R code involves two loops, which could be very slow even for R-3.01 or any higher version. The corresponding C++ code is as follows.

```{r,eval=FALSE}
NumericMatrix gibbsC(int N, int thin) {
  NumericMatrix mat(N, 2);
  double x = 0, y = 0;
  for(int i = 0; i < N; i++) {
    for(int j = 0; j < thin; j++) {
      x = rgamma(1, 3, 1 / (y * y + 4))[0];
      y = rnorm(1, 1 / (x + 1), 1 / sqrt(2 * (x + 1)))[0];
    }
    mat(i, 0) = x;
    mat(i, 1) = y;
  }
  return(mat);
}
```

The R code for benchmarking _gibbsR_ and _gibbsC_ is as follows.

```{r,eval=FALSE}
tm2 <- microbenchmark(
  vR = gibbsR(1000, 10),
  vC = gibbsC(1000, 10)
)
knitr::kable(summary(tm2)[,c(1,3,5,6)])
```

The results again show an evident computational speed gain of C++ against R.

```{r}
library(abess)
dat=generate.data(70,30,10)
dat
```


